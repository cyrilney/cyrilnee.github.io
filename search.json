[{"title":"Leetcode No.199 binary tree right side view","url":"/2020/04/22/Leetcode-No-199-binary-tree-right-side-view/","content":"\n\n### 描述\n2020年4月22日每日一题：给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。\n\n示例:\n\n    输入: [1,2,3,null,5,null,4]\n    输出: [1, 3, 4]\n    解释:\n\n       1            <---\n     /   \\\n    2     3         <---\n     \\     \\\n      5     4       <---\n\n### 思路\n题目较为简单，右侧深搜即可。全局使用列表保存对应深度下出现的第一个元素即为答案\n\n### 复杂度: O(n)\n\n\n\n### Answers Code\n    # Definition for a binary tree node.\n    # class TreeNode:\n    #     def __init__(self, x):\n    #         self.val = x\n    #         self.left = None\n    #         self.right = None\n\n    class Solution:\n        def __init__(self):\n            self.ans = []\n\n        def rightSideView(self, root: TreeNode) -> List[int]:\n            if not root :\n                return []\n            self.rightDfs(root, 0);\n            return self.ans\n\n        def rightDfs(self, root: TreeNode, depth: int):\n            if not root:\n                return\n            if depth >= len(self.ans):\n                self.ans.append(root.val)\n            self.rightDfs(root.right, depth+1)\n            self.rightDfs(root.left, depth+1)\n","tags":["Leetcode, 每日一题"]},{"title":"Leetcode No.864 shortest path to get all keys.","url":"/2020/04/22/Leetcode-No-864-shortest-path-to-get-all-keys/","content":"\n### 描述\n给定一个二维网格 grid。 \".\" 代表一个空房间， \"#\" 代表一堵墙， \"@\" 是起点，（\"a\", \"b\", ...）代表钥匙，（\"A\", \"B\", ...）代表锁。\n\n我们从起点开始出发，一次移动是指向四个基本方向之一行走一个单位空间。我们不能在网格外面行走，也无法穿过一堵墙。如果途经一个钥匙，我们就把它捡起来。除非我们手里有对应的钥匙，否则无法通过锁。\n\n假设 K 为钥匙/锁的个数，且满足 1 <= K <= 6，字母表中的前 K 个字母在网格中都有自己对应的一个小写和一个大写字母。换言之，每个锁有唯一对应的钥匙，每个钥匙也有唯一对应的锁。另外，代表钥匙和锁的字母互为大小写并按字母顺序排列。\n\n返回获取所有钥匙所需要的移动的最少次数。如果无法获取所有钥匙，返回 -1 。\n\n其中：\n1. 1 <= grid.length <= 30\n2. 1 <= grid[0].length <= 30\n3. grid[i][j] 只含有 '.', '#', '@', 'a'-'f' 以及 'A'-'F'\n钥匙的数目范围是 [1, 6]，每个钥匙都对应一个不同的字母，正好打开一个对应的锁。\n\n### 思路\n一开始看到题目可以想到也许可以使用搜索解决。又因数字方位进一步验证了我的猜想。如思路如下：\n1. 先确定K，使用深搜递归出一个钥匙获取顺序。如 \"acbdef\"\n2. 根据获取顺序。从起点开始进行多次广搜 a => c  => b => d  => e  => f计算出一共的最短距离。\n3. 广搜过程中遇墙则结束，遇到锁则判断钥匙是否已经在之前拿过了即为通过。\n4. 最短距离取最小值。\n\n### 复杂度: O(K!K*nm)\n\n由于K<=6，k!最大值为720。单次广搜最坏情况为NM(30*30)，该解法最坏情况3,888,000\n\n### Answers Code\n\n    class Solution {\n\n        // 广搜节点  定义横坐标 纵坐标 和 步数\n        static class Loc {\n            public int x;\n            public int y;\n            public int step;\n\n            @Override\n            public boolean equals(Object obj) {\n                if (!(obj instanceof Loc))\n                    return super.equals(obj);\n                Loc loc = (Loc) obj;\n                return this.x == loc.x && this.y == loc.y;\n            }\n\n            @Override\n            public int hashCode() {\n                return this.x * 40 + this.y;\n            }\n\n            public Loc(int x, int y, int step) {\n                this.x = x;\n                this.y = y;\n                this.step = step;\n            }\n\n            public Loc(int x, int y) {\n                this(x, y, 0);\n            }\n        }\n\n        final static Loc[] dir = new Loc[]{new Loc(0, 1), new Loc(1, 0), new Loc(0, -1), new Loc(-1, 0)};\n\n        public int shortestPathAllKeys(String[] grid) {\n            Character kChar = null;\n            for (int i = 0; i < grid.length; i++) {\n                for (int j = 0; j < grid[i].length(); j++) {\n                    if (grid[i].charAt(j) <= 'z' && grid[i].charAt(j) >= 'a') {\n                        if (kChar == null || kChar < grid[i].charAt(j))\n                            kChar = grid[i].charAt(j);\n                    }\n                }\n            }\n\n            return this.work(0, kChar - 'a' + 1, Collections.emptySet(), \"\", grid);\n\n        }\n\n        public int work(int cur, int maxDeep, Set<Character> had, String aim, String[] grid) {\n\n            // 递归到最后一层。 开始for循环广搜处理\n            if (cur == maxDeep) {\n                char startChar = '@';\n                int total = 0;\n                Loc startLoc = new Loc(0, 0, 0);\n                had = new HashSet<>();\n                for (int k = 0; k < maxDeep; k++) {\n                    changeLocStart(startLoc, startChar, grid);\n                    startLoc.step = total;\n                    int temp = bfs(grid, startLoc, had, aim.charAt(k));\n                    if (temp == -1) {\n                        return -1;\n                    }\n                    total = temp;\n                    had.add(aim.charAt(k));\n                    startChar = aim.charAt(k);\n                }\n                return total;\n\n            }\n            int max = Integer.MAX_VALUE;\n            for (char i = 'a'; i < 'a' + maxDeep; i++) {\n                if (had.contains(i))\n                    continue;\n                Set<Character> newHad = new HashSet<>(had);\n                newHad.add(i);\n                int r = work(cur + 1, maxDeep, newHad, aim + i, grid);\n                if (r != -1) {\n                    max = Math.min(max, r);\n                }\n            }\n            return max == Integer.MAX_VALUE ? -1 : max;\n        }\n\n        private void changeLocStart(Loc startLoc, char target, String[] grid) {\n            for (int i = 0; i < grid.length; i++) {\n                for (int j = 0; j < grid[i].length(); j++) {\n                    if (grid[i].charAt(j) == target) {\n                        startLoc.x = i;\n                        startLoc.y = j;\n                        return;\n                    }\n                }\n            }\n        }\n\n        // 广搜，查询起点到终点\n        private int bfs(String[] grid, Loc start, Set<Character> had, Character target) {\n            Queue<Loc> q = new LinkedList<>();\n            Set<Loc> used = new HashSet<>();\n\n            q.offer(start);\n\n            while (!q.isEmpty()) {\n                Loc front = q.poll();\n                if (used.contains(front)) {\n                    continue;\n                }\n                used.add(front);\n                if (grid[front.x].charAt(front.y) == target)\n                    return front.step;\n\n                for (int i = 0; i < dir.length; i++) {\n                    Loc nxt = new Loc(front.x + dir[i].x, front.y + dir[i].y, front.step + 1);\n\n                    if (nxt.x < 0 || nxt.x >= grid.length || nxt.y < 0 || nxt.y >= grid[0].length()) {\n                        continue;\n                    }\n\n                    if (grid[nxt.x].charAt(nxt.y) == '#')\n                        continue;\n                    else if (grid[nxt.x].charAt(nxt.y) == '.' || grid[nxt.x].charAt(nxt.y)== '@'\n                            || (grid[nxt.x].charAt(nxt.y) >= 'a' && grid[nxt.x].charAt(nxt.y) <= 'z')) {\n                        q.offer(nxt);\n                    } else if (grid[nxt.x].charAt(nxt.y) >= 'A' && grid[nxt.x].charAt(nxt.y) <= 'Z') {\n                        Character need = (char) (grid[nxt.x].charAt(nxt.y) - ('Z' - 'z'));\n                        if (!had.contains(need)) {\n                            continue;\n                        }\n                        q.offer(nxt);\n                    }\n\n                }\n            }\n            return -1;\n\n        }\n\n        public static void main(String[] args) {\n            Solution solution = new Solution();\n            System.out.println(\"case 1\");\n            System.out.println(solution.shortestPathAllKeys(new String[]{\"@.a.#\",\"###.#\",\"b.A.B\"}));\n            System.out.println(\"case 2\");\n            System.out.println(solution.shortestPathAllKeys(new String[]{\"@..aA\",\"..B#.\",\"....b\"}));\n        }\n    }\n    //leetcode submit region end(Prohibit modification and deletion)\n","tags":["Leetcode"]},{"title":"红黑树","url":"/2019/11/24/红黑树/","content":"\n## 红黑树\n我们都知道平衡二叉查找树（排序树）在极端情况下，查询效率为O(N)。因此需要一个自平衡的数据结构保证查找效率。本片主角红黑树树就这样诞生了。\n\n>\n> 红黑树（英语：Red–black tree）是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组。它在1972年由鲁道夫·贝尔发明，被称为\"对称二叉B树\"，它现代的名字源于Leo J. Guibas和Robert Sedgewick于1978年写的一篇论文。红黑树的结构复杂，但它的操作有着良好的最坏情况运行时间，并且在实践中高效：它可以在log n时间内完成查找，插入和删除，这里的n是树中元素的数目.\n>\n> —— 摘自wiki对红黑树的介绍\n\n### 性质\n红黑树是一颗查询复杂度保持在O(log N) 的自平衡二叉查找树。在原有的二叉查找树的性质下，通过给节点上色满足如下性质实现：\n* **节点是红色或黑色。**\n* **根是黑色。**\n* **所有叶子都是黑色（叶子节点指NIL节点）。**\n* **每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）**\n* **从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。**\n\n具体的某个红黑树入大概入下图所示。 注意**任何红黑树都要满足上面五条性质。**\n\n![](https://blog-bucket-1300756499.cos.ap-chengdu.myqcloud.com/%E7%BA%A2%E9%BB%91%E6%A0%91.png)\n\n\n### 操作\n\n红黑树的操作包括新增、删除、和查询操作。 查询操作与之前的二叉树查找树雷同，这里略过。额外地，需要说明一下二叉查找树中的旋转操作\n\n#### 旋转\n\n二叉排序树的旋转指的是不破坏二叉树性质的情况下，改变树的结构的一种操作。具体分为如下两种操作：\n\n* 左旋， 将树进行逆时针旋转。如图所示，节点E进行左旋，原本E的右子树接替E的位置称为父亲，E成为S节点的左孩子。注意如果S原本有左子树（左子树的值应该在E到S之间），将该树称为E的新右儿子。仍然满足二叉排序树的规则：\n\n![](https://blog-bucket-1300756499.cos.ap-chengdu.myqcloud.com/rotationLeft.gif)\n\n* 右旋，将树进行顺时针旋转。左旋的镜像操作。如图所示：\n\n![](https://blog-bucket-1300756499.cos.ap-chengdu.myqcloud.com/rotationRight.gif)\n\n注意，旋转是满足二叉排序树的结构变化操作。 旋转后的节点高度可能会发生变化。 红黑树而言，可能会导致与其性质冲突。 因此需要再对红黑树进行重染色。\n\n#### 新增\n\n红黑树新增时，默认新增的是红色节点。一种情况是，如果节点是根结点，则将树染红即可；一种简单的情况是，当节点的父亲是黑色节点时显然不会违反之前的规则。当父亲节点是红色节点时。需要分情况讨论。\n\n1. 当节点的叔叔节点（父亲节点的兄弟节点）是红色时。 将父亲节点和叔叔节点染黑，将爷爷节点染红。这样操作后，所有经过父亲节点和叔叔节点黑色节点数不变，满足**性质5**，但爷爷节点染红后可能会导致它其与上层节点的冲突。因此当前指针指向爷爷节点，重新进行一次判断。\n![](https://blog-bucket-1300756499.cos.ap-chengdu.myqcloud.com/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%8F%92%E5%85%A51.png)\n\n2. 当前节点的叔叔节点为黑色时，分如下两种情况来讨论（这里以父亲节点为左子树来判断，若是右子树则镜像操作即可）\n   1. 当前节点是父亲节点的左子树。 则将父亲节点染黑，爷爷节点染红。 再对爷爷进行右旋操作。 此时经过父亲节点的节点和黑节点数不变（满足**性质5**）。\n      ![](https://blog-bucket-1300756499.cos.ap-chengdu.myqcloud.com/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%8F%92%E5%85%A5%202.1.png)\n\n   2. 当前节点是父亲节点的右子树。则将父亲节点进行左旋，当前指针指向原来的父节点。此时当前节点变为父亲节点的左子树。 按照 2.1 的方式处理。\n![](https://blog-bucket-1300756499.cos.ap-chengdu.myqcloud.com/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%8F%92%E5%85%A5%202.2.png)\n\n\n#### 删除\n\n删除操作比较复杂。 大概跟味两部分：删除流程和删除节点后平衡操作。\n\n##### 删除流程\n\n首先通过二分操作找到需要删除的节点。根据当前节点判断是否能删除：\n\n1. 如果被删除节点有两个孩子：直接寻找该节点的中序后继（即右子树中最小的节点）。后继节点的值覆盖当前节点值。指针指向后继重新进行判断。\n2. 如果被删除节点有一个孩子或孩子都为 NIL：则继续进行判断\n  1. 如果被删除节点是红色节点：直接将孩子节点顶替当前节点。不会影响到性质。\n  2. 如果被删除节点是黑色节点，且其孩子节点为红色：将孩子节点顶替当前节点，再讲孩子节点染黑即可。\n  3. 如果被删除节点是黑色节点，且孩子节点都为黑色（此时孩子节点必为NIL节点，否则单独节点为黑色不满足性质5）：当时情况较为复杂，则进行以下删除后平衡操作。\n\n##### 删除后平衡操作\n\n首先是如果当前节点已经是根结点了，则将根结点染黑。\n\n我们将删除前的节点定义为N（先平衡，再删除替换节点），节点的父节点为P， 兄弟节点为S，兄弟节点的左子树为SL，右子树为SR。我们遍历N、P、S、SL、SR可能有的情况有如下几种，我们将主意进行讨论。（下文将由N节点为P节点的左子树进行讨论。若为右子树，镜像操作即可）\n\n|  N  |  P  |  S  |  SL  |  SR  |  case  |\n| --- | --- | --- | --- | --- |--- |\n|  B  |  S  |  B  |  B(NIL)  |  B(NIL)  | (1) |\n|  B  |  B  |  B  |  B(NIL)  |  B(NIL)  |  (2) |\n|  B  |  B  | S  |  B  |  B  |  (3)  |\n|  B  | B(or S)  | B  |  S  |  B(NIL)  |  (4)  |\n|  B  |  B(or S)  |  B  |  S(or B(NIL))  |  S  |  (5)  |\n\n1. 删除节点为黑色， 父亲节点为红色， S节点为黑色， 且S节点的孩子SL、SR都为黑色（NIL节点）。 则将P节点染黑，S节点染红。则经过S节点的黑色节点数不变。经过N的黑色节点数补齐。满足相关性质。\n![](https://blog-bucket-1300756499.cos.ap-chengdu.myqcloud.com/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A4%201.png)\n2. 删除节点为黑色， 父亲节点为黑色， S节点为黑色， 且S节点的孩子SL、SR都为黑色（NIL节点）。将S节点染红。此时通过N节点和通过S节节点，即通过P的比删除前少1。将当前指针指向P节点，重新执行平衡操作。\n![](https://blog-bucket-1300756499.cos.ap-chengdu.myqcloud.com/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A4%202.png)\n\n3. 删除节点为黑色，父亲节点为黑色，S节点为红色，则S节点的孩子SL、SR都为黑色。将P节点染红，S节点染黑，再对叶子节点进行左旋。此时经过S节点的数量不变。经过N的节点仍然少1，此时P为红色。按照情况4、5进行判断。\n![](https://blog-bucket-1300756499.cos.ap-chengdu.myqcloud.com/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A4%203.png)\n\n4. 删除节点为黑色，父亲节点为红色或者为黑色，S节点为黑色，其左SL节点为红色，右节点为黑色（为NIL）。将SL染黑，S染红，S节点右旋。这样S和SL角色互换，可以按照情况5判断。\n![](https://blog-bucket-1300756499.cos.ap-chengdu.myqcloud.com/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A44.png)\n\n5. 删除节点为黑色，父亲节点为红色或者黑色，S节点为黑色。其右子树SR为红色（SL为红色或黑（NIL））。S节点染为P节点的颜色，P节点染黑，SR节点染黑，P节点左旋。 此时SR节点不变， SL节点和N节点恢复。满足规律5。恢复平衡。\n![](https://blog-bucket-1300756499.cos.ap-chengdu.myqcloud.com/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A45.png)\n\n\n### 证明\n\n我们在之前说过红黑树的查询效率是log2(n)。但具体为什么根据前面5条性质即确定红黑树的具体查询效率的呢？需要进行证明：\n\n首先定义 BH(v) 为节点黑色高度（ 红黑树的节点v上到他的叶子节点的黑色节点的个数，不计v本身）、TOTAL[ BH(v) ] 为 当黑高为 BH(v 时，树可能有的总叶子节点个数 可知\n\n\n1. BH(v) = 0 时 v 此时可能为空节点或只有v本身 、TOTAL[ BH(v) ] 最小为 0\n\n2. 当 BH(v) > 0 时： 根据 **性质5** 黑高为 BH(V) 的 红黑树， 其子树的黑高至少为 BH(V) - 1 （或子树的高度仍为 BH(V) ）即数的节点总数\n\n$$\nTOTAL[BH(v)] \\geq 2 \\cdot TOTAL[BH(v) - 1] + 1\n$$\n\n由此可得\n\n$$\nTOTAL[BH(v)] = 2^{BH(v)} - 1\n$$\n\n\n因此BH(V) 跟 TOTAL[V] 之间满足指数关系。又由**性质4**可知，树的黑高至少为这棵树的二分之一。 即 BH(V) >= H(V) / 2，可得，对于根结点root而言。有\n\n$$\n\nn \\geq 2^{BH(root)} - 1\n\n=> n \\geq 2^{H(root) \\div 2} - 1\n\n=> n + 1 \\geq 2^{H(root) \\div 2}\n\n=> log_2(n + 1) \\geq H(root) \\div 2\n\n=>  H(root) \\leq 2 \\cdot log_2(n + 1)\n\n$$\n\n### 与 avl 的比较\n\n两者都是经过优化的自平衡二叉树。有各自的自平衡算法，增删查效率都是log(n)但有一些区别。但从平衡性而言，AVL的平衡性更加严格，如下图所示情况。 红黑树允许较低的平衡性（但复杂度仍为log(n)）换取更少的自平衡操作。由于avl数平衡性高于红黑树，查询效率上会高于红黑树（但复杂度仍为log(n)）。红黑树算是比较「折衷」的平衡树方案，C++的STL中和JAVA的TreeMap&HashMap都实现了红黑树以达到O(log(n)) 的插入删除的效果\n\n\n\n\n<style>\nimg {\nmargin:auto;\nwidth:61.8%;\n}\n</style>\n","tags":["数据结构"]},{"title":"Hello World","url":"/2019/11/22/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"},{"title":"tags","url":"/tags/index.html"}]